/**
 * Calculates the number of bits required to store the value using 2s complement
 * encoding.
 * 
 * @param value the value to check the bit width of
 * @return the number of bits required to store the value using 2s complement encoding
 */
template <typename T, std::enable_if_t<std::is_signed_v<T> && std::is_integral_v<T>, bool> = true>
constexpr auto signed_bit_width(T value) -> int
{
   using signed_t = std::make_unsigned_t<T>;
   if (value < 0)
   {
      const auto positive = static_cast<signed_t>(-(value + 1)) + 1u;  // prevent overflow when value == std::numeric_limits<signed_t>::lowest()
      const auto bw1 = bit_width(positive);
      const auto bw2 = bit_width(positive - 1u);
      return (bw2 < bw1) ? bw1 : (bw1 + 1);
   }
   else
   {
      return bit_width(static_cast<signed_t>(value)) + 1;
   }
}